diff --git a/backend/src/Execora.Api/Controllers/Auth/RegisterController.cs b/backend/src/Execora.Api/Controllers/Auth/RegisterController.cs
index 2430929..5a6d860 100644
--- a/backend/src/Execora.Api/Controllers/Auth/RegisterController.cs
+++ b/backend/src/Execora.Api/Controllers/Auth/RegisterController.cs
@@ -15,13 +15,16 @@ namespace Execora.Api.Controllers.Auth;
 public class RegisterController : ControllerBase
 {
     private readonly IRegistrationService _registrationService;
+    private readonly IEmailVerificationService _emailVerificationService;
     private readonly ILogger<RegisterController> _logger;
 
     public RegisterController(
         IRegistrationService registrationService,
+        IEmailVerificationService emailVerificationService,
         ILogger<RegisterController> logger)
     {
         _registrationService = registrationService;
+        _emailVerificationService = emailVerificationService;
         _logger = logger;
     }
 
@@ -78,38 +81,32 @@ public async Task<IActionResult> Register(
     /// <summary>
     /// Verify email address
     /// </summary>
-    /// <param name="userId">User ID</param>
-    /// <param name="token">Verification token</param>
+    /// <param name="request">Verification request containing token</param>
     /// <param name="cancellationToken">Cancellation token</param>
-    /// <returns>Success result</returns>
-    [HttpGet("{userId:guid}/verify")]
+    /// <returns>Verification response</returns>
+    [HttpPost("verify-email")]
     public async Task<IActionResult> VerifyEmail(
-        [FromRoute] Guid userId,
-        [FromQuery] string token,
+        [FromBody] VerifyEmailRequest request,
         CancellationToken cancellationToken = default)
     {
         try
         {
-            var success = await _registrationService.VerifyEmailAsync(userId, token, cancellationToken);
+            _logger.LogInformation("Email verification attempt with token");
 
-            if (success)
+            var response = await _emailVerificationService.VerifyEmailAsync(request.Token, cancellationToken);
+
+            if (response.Success)
             {
-                return Ok(new
-                {
-                    message = "Email verified successfully"
-                });
+                _logger.LogInformation("Email verified successfully for: {Email}", response.Email);
+                return Ok(response);
             }
 
-            return BadRequest(new
-            {
-                type = "https://example.com/probs/verification-failed",
-                title = "Email verification failed",
-                detail = "Invalid or expired verification token"
-            });
+            _logger.LogWarning("Email verification failed: {ErrorMessage}", response.ErrorMessage);
+            return BadRequest(response);
         }
         catch (Exception ex)
         {
-            _logger.LogError(ex, "Email verification failed for user: {UserId}", userId);
+            _logger.LogError(ex, "Unexpected error during email verification");
             return StatusCode(500, new
             {
                 type = "https://example.com/probs/verification-error",
@@ -122,26 +119,33 @@ public async Task<IActionResult> VerifyEmail(
     /// <summary>
     /// Resend email verification token
     /// </summary>
-    /// <param name="userId">User ID</param>
+    /// <param name="request">Resend verification request containing email</param>
     /// <param name="cancellationToken">Cancellation token</param>
-    /// <returns>Success result</returns>
-    [HttpPost("{userId:guid}/resend-verification")]
+    /// <returns>Resend verification response</returns>
+    [HttpPost("resend-verification")]
     public async Task<IActionResult> ResendVerificationEmail(
-        [FromRoute] Guid userId,
+        [FromBody] ResendVerificationRequest request,
         CancellationToken cancellationToken = default)
     {
         try
         {
-            await _registrationService.ResendVerificationEmailAsync(userId, cancellationToken);
+            _logger.LogInformation("Verification email resend attempt for: {Email}", request.Email);
 
-            return Ok(new
+            var response = await _emailVerificationService.ResendVerificationEmailAsync(request.Email, cancellationToken);
+
+            if (response.Success)
             {
-                message = "Verification email resent successfully"
-            });
+                _logger.LogInformation("Verification email resent to: {Email}", request.Email);
+                return Ok(response);
+            }
+
+            _logger.LogWarning("Failed to resend verification email to: {Email}. Error: {ErrorMessage}",
+                request.Email, response.ErrorMessage);
+            return BadRequest(response);
         }
         catch (Exception ex)
         {
-            _logger.LogError(ex, "Failed to resend verification email for user: {UserId}", userId);
+            _logger.LogError(ex, "Unexpected error resending verification email to: {Email}", request.Email);
             return StatusCode(500, new
             {
                 type = "https://example.com/probs/resend-verification-error",
diff --git a/backend/src/Execora.Api/Program.cs b/backend/src/Execora.Api/Program.cs
index 2990663..484cf42 100644
--- a/backend/src/Execora.Api/Program.cs
+++ b/backend/src/Execora.Api/Program.cs
@@ -15,6 +15,8 @@
 using Microsoft.OpenApi.Models;
 using System.Reflection;
 using System.Text;
+using FluentValidation;
+using Execora.Application.Validators;
 
 namespace Execora.Api;
 
@@ -207,6 +209,13 @@ private static void ConfigureServices(IServiceCollection services, IConfiguratio
         // Register Registration Service (Phase 3)
         services.AddScoped<IRegistrationService, RegistrationService>();
 
+        // Register Email Verification Services (Phase 4)
+        services.AddScoped<IEmailVerificationService, EmailVerificationService>();
+        services.AddScoped<IEmailVerificationTokenRepository, EmailVerificationTokenRepository>();
+
+        // Register Validators
+        services.AddValidatorsFromAssemblyContaining<RegistrationValidator>();
+
         // Health Checks
         services.AddHealthChecks()
             .AddDbContextCheck<ExecoraDbContext>("database");
diff --git a/backend/src/Execora.Application/DTOs/RegisterResponse.cs b/backend/src/Execora.Application/DTOs/RegisterResponse.cs
index b8a7292..deb20c1 100644
--- a/backend/src/Execora.Application/DTOs/RegisterResponse.cs
+++ b/backend/src/Execora.Application/DTOs/RegisterResponse.cs
@@ -43,7 +43,7 @@ public record RegisterResponse
     /// <summary>
     /// Email verification status
     /// </summary>
-    public bool EmailConfirmed { get; init; }
+    public bool EmailVerified { get; init; }
 
     /// <summary>
     /// Email verification token (for client verification)
diff --git a/backend/src/Execora.Application/DTOs/ResendVerificationRequest.cs b/backend/src/Execora.Application/DTOs/ResendVerificationRequest.cs
new file mode 100644
index 0000000..5ebec63
--- /dev/null
+++ b/backend/src/Execora.Application/DTOs/ResendVerificationRequest.cs
@@ -0,0 +1,12 @@
+namespace Execora.Application.DTOs;
+
+/// <summary>
+/// Request model for resending verification email
+/// </summary>
+public class ResendVerificationRequest
+{
+    /// <summary>
+    /// Gets or sets the email address to send verification to
+    /// </summary>
+    public required string Email { get; set; }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Application/DTOs/VerifyEmailRequest.cs b/backend/src/Execora.Application/DTOs/VerifyEmailRequest.cs
new file mode 100644
index 0000000..74e9286
--- /dev/null
+++ b/backend/src/Execora.Application/DTOs/VerifyEmailRequest.cs
@@ -0,0 +1,12 @@
+namespace Execora.Application.DTOs;
+
+/// <summary>
+/// Request model for email verification
+/// </summary>
+public class VerifyEmailRequest
+{
+    /// <summary>
+    /// Gets or sets the verification token from the email link
+    /// </summary>
+    public required string Token { get; set; }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Application/DTOs/VerifyEmailResponse.cs b/backend/src/Execora.Application/DTOs/VerifyEmailResponse.cs
new file mode 100644
index 0000000..f0f87ed
--- /dev/null
+++ b/backend/src/Execora.Application/DTOs/VerifyEmailResponse.cs
@@ -0,0 +1,32 @@
+namespace Execora.Application.DTOs;
+
+/// <summary>
+/// Response model for email verification
+/// </summary>
+public class VerifyEmailResponse
+{
+    /// <summary>
+    /// Gets or sets a value indicating whether the email was successfully verified
+    /// </summary>
+    public bool Success { get; set; }
+
+    /// <summary>
+    /// Gets or sets a value indicating whether the email is now verified
+    /// </summary>
+    public bool EmailVerified { get; set; }
+
+    /// <summary>
+    /// Gets or sets an error message if verification failed
+    /// </summary>
+    public string? ErrorMessage { get; set; }
+
+    /// <summary>
+    /// Gets or sets a success message if verification succeeded
+    /// </summary>
+    public string? SuccessMessage { get; set; }
+
+    /// <summary>
+    /// Gets or sets the email address that was verified
+    /// </summary>
+    public string? Email { get; set; }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Application/Services/EmailVerificationService.cs b/backend/src/Execora.Application/Services/EmailVerificationService.cs
new file mode 100644
index 0000000..d19e37c
--- /dev/null
+++ b/backend/src/Execora.Application/Services/EmailVerificationService.cs
@@ -0,0 +1,310 @@
+using Execora.Application.DTOs;
+using Execora.Core.Entities;
+using Execora.Core.Enums;
+using Execora.Core.Interfaces;
+using Execora.Infrastructure.Services.Email;
+using Microsoft.Extensions.Logging;
+
+namespace Execora.Application.Services;
+
+/// <summary>
+/// Service for handling email verification flows
+/// </summary>
+public class EmailVerificationService : IEmailVerificationService
+{
+    private readonly IUserRepository _userRepository;
+    private readonly IEmailVerificationTokenRepository _tokenRepository;
+    private readonly IEmailService _emailService;
+    private readonly ILogger<EmailVerificationService> _logger;
+    private readonly TimeSpan _tokenLifetime = TimeSpan.FromHours(24); // 24 hour expiration
+
+    public EmailVerificationService(
+        IUserRepository userRepository,
+        IEmailVerificationTokenRepository tokenRepository,
+        IEmailService emailService,
+        ILogger<EmailVerificationService> logger)
+    {
+        _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository));
+        _tokenRepository = tokenRepository ?? throw new ArgumentNullException(nameof(tokenRepository));
+        _emailService = emailService ?? throw new ArgumentNullException(nameof(emailService));
+        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
+    }
+
+    /// <summary>
+    /// Generates a new verification token for a user
+    /// </summary>
+    public async Task<EmailVerificationToken> GenerateVerificationTokenAsync(string email)
+    {
+        _logger.LogInformation("Generating verification token for email: {Email}", email);
+
+        // Clean up any existing tokens for this email
+        await _tokenRepository.DeleteByEmailAsync(email);
+
+        var user = await _userRepository.GetByEmailAsync(email) ??
+            throw new KeyNotFoundException($"User with email {email} not found");
+
+        if (user.EmailVerified)
+        {
+            _logger.LogInformation("Email {Email} is already verified", email);
+            throw new InvalidOperationException("Email is already verified");
+        }
+
+        // Generate secure token
+        var token = Guid.NewGuid().ToString("N");
+        var hashedToken = HashToken(token);
+
+        var verificationToken = new EmailVerificationToken
+        {
+            Email = email,
+            Token = hashedToken,
+            ExpiresAt = DateTime.UtcNow.Add(_tokenLifetime),
+            UserId = user.Id,
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await _tokenRepository.CreateAsync(verificationToken);
+        _logger.LogInformation("Generated verification token for email: {Email}", email);
+
+        // Return the unhashed token for email sending
+        verificationToken.Token = token;
+        return verificationToken;
+    }
+
+    /// <summary>
+    /// Verifies an email using the provided token
+    /// </summary>
+    public async Task<VerifyEmailResponse> VerifyEmailAsync(string token)
+    {
+        _logger.LogInformation("Verifying email with token");
+
+        try
+        {
+            // Hash the token for lookup
+            var hashedToken = HashToken(token);
+
+            // Get the verification token
+            var verificationToken = await _tokenRepository.GetByTokenAsync(hashedToken);
+            if (verificationToken == null)
+            {
+                _logger.LogWarning("Invalid verification token used");
+                return new VerifyEmailResponse
+                {
+                    Success = false,
+                    EmailVerified = false,
+                    ErrorMessage = "Invalid verification token"
+                };
+            }
+
+            // Check if token is expired
+            if (verificationToken.ExpiresAt <= DateTime.UtcNow)
+            {
+                _logger.LogWarning("Verification token expired for email: {Email}", verificationToken.Email);
+                return new VerifyEmailResponse
+                {
+                    Success = false,
+                    EmailVerified = false,
+                    ErrorMessage = "Verification token has expired"
+                };
+            }
+
+            // Check if token is already used
+            if (verificationToken.IsUsed)
+            {
+                _logger.LogWarning("Verification token already used for email: {Email}", verificationToken.Email);
+                return new VerifyEmailResponse
+                {
+                    Success = false,
+                    EmailVerified = false,
+                    ErrorMessage = "Verification token has already been used"
+                };
+            }
+
+            // Get the user
+            var user = await _userRepository.GetByEmailAsync(verificationToken.Email);
+            if (user == null)
+            {
+                _logger.LogWarning("User not found for email: {Email}", verificationToken.Email);
+                return new VerifyEmailResponse
+                {
+                    Success = false,
+                    EmailVerified = false,
+                    ErrorMessage = "User not found"
+                };
+            }
+
+            // Mark token as used
+            verificationToken.IsUsed = true;
+            verificationToken.UsedAt = DateTime.UtcNow;
+            await _tokenRepository.UpdateAsync(verificationToken);
+
+            // Mark user as verified
+            user.EmailVerified = true;
+            await _userRepository.UpdateAsync(user);
+
+            _logger.LogInformation("Email verified successfully for: {Email}", verificationToken.Email);
+
+            return new VerifyEmailResponse
+            {
+                Success = true,
+                EmailVerified = true,
+                SuccessMessage = "Email verified successfully",
+                Email = verificationToken.Email
+            };
+        }
+        catch (Exception ex)
+        {
+            _logger.LogError(ex, "Error during email verification");
+            return new VerifyEmailResponse
+            {
+                Success = false,
+                EmailVerified = false,
+                ErrorMessage = "An error occurred during verification"
+            };
+        }
+    }
+
+    /// <summary>
+    /// Resends a verification email to a user
+    /// </summary>
+    public async Task<ResendVerificationResponse> ResendVerificationEmailAsync(string email)
+    {
+        _logger.LogInformation("Resending verification email to: {Email}", email);
+
+        try
+        {
+            var user = await _userRepository.GetByEmailAsync(email);
+            if (user == null)
+            {
+                _logger.LogWarning("User not found for email: {Email}", email);
+                return new ResendVerificationResponse
+                {
+                    Success = false,
+                    ErrorMessage = "User not found"
+                };
+            }
+
+            if (user.EmailVerified)
+            {
+                _logger.LogWarning("Email {Email} is already verified", email);
+                return new ResendVerificationResponse
+                {
+                    Success = false,
+                    ErrorMessage = "Email is already verified"
+                };
+            }
+
+            // Generate new token
+            var verificationToken = await GenerateVerificationTokenAsync(email);
+
+            // Send email
+            await SendVerificationEmailAsync(email, verificationToken.Token);
+
+            _logger.LogInformation("Verification email resent to: {Email}", email);
+
+            return new ResendVerificationResponse
+            {
+                Success = true,
+                SuccessMessage = "Verification email resent successfully",
+                NewToken = verificationToken.Token
+            };
+        }
+        catch (Exception ex)
+        {
+            _logger.LogError(ex, "Error resending verification email to: {Email}", email);
+            return new ResendVerificationResponse
+            {
+                Success = false,
+                ErrorMessage = "Failed to resend verification email"
+            };
+        }
+    }
+
+    /// <summary>
+    /// Gets the verification status for a user
+    /// </summary>
+    public async Task<VerificationStatusResponse> GetVerificationStatusAsync(string email)
+    {
+        _logger.LogDebug("Getting verification status for email: {Email}", email);
+
+        try
+        {
+            var user = await _userRepository.GetByEmailAsync(email);
+            if (user == null)
+            {
+                return new VerificationStatusResponse
+                {
+                    IsVerified = false,
+                    Status = "User not found",
+                    Email = email
+                };
+            }
+
+            var response = new VerificationStatusResponse
+            {
+                IsVerified = user.EmailVerified,
+                Email = email
+            };
+
+            if (user.EmailVerified)
+            {
+                response.Status = "Email is already verified";
+            }
+            else
+            {
+                response.Status = "Email verification pending";
+                response.HasPendingVerification = true;
+
+                // Check if there's an active token
+                var tokens = await _tokenRepository.GetByEmailAsync(email);
+                var activeToken = tokens.FirstOrDefault(t => !t.IsUsed && t.ExpiresAt > DateTime.UtcNow);
+                if (activeToken != null)
+                {
+                    response.TokenExpiresAt = activeToken.ExpiresAt;
+                }
+            }
+
+            return response;
+        }
+        catch (Exception ex)
+        {
+            _logger.LogError(ex, "Error getting verification status for email: {Email}", email);
+            return new VerificationStatusResponse
+            {
+                IsVerified = false,
+                Status = "Error checking verification status",
+                Email = email
+            };
+        }
+    }
+
+    /// <summary>
+    /// Clean up expired verification tokens
+    /// </summary>
+    public async Task<int> CleanupExpiredTokensAsync()
+    {
+        _logger.LogInformation("Cleaning up expired verification tokens");
+        var count = await _tokenRepository.DeleteExpiredTokensAsync();
+        _logger.LogInformation("Cleaned up {Count} expired verification tokens", count);
+        return count;
+    }
+
+    /// <summary>
+    /// Hashes a token for secure storage
+    /// </summary>
+    private string HashToken(string token)
+    {
+        // Using SHA-256 for hashing - in production, consider Argon2 or similar
+        using var sha256 = System.Security.Cryptography.SHA256.Create();
+        var hashBytes = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(token));
+        return Convert.ToBase64String(hashBytes);
+    }
+
+    /// <summary>
+    /// Sends verification email to the user
+    /// </summary>
+    private async Task SendVerificationEmailAsync(string email, string token)
+    {
+        var userName = "User"; // In a real implementation, get user's name
+        await _emailService.SendEmailVerificationAsync(email, token, userName);
+    }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Application/Services/IEmailVerificationService.cs b/backend/src/Execora.Application/Services/IEmailVerificationService.cs
new file mode 100644
index 0000000..a12d4fb
--- /dev/null
+++ b/backend/src/Execora.Application/Services/IEmailVerificationService.cs
@@ -0,0 +1,101 @@
+using Execora.Application.DTOs;
+using Execora.Core.Entities;
+
+namespace Execora.Application.Services;
+
+/// <summary>
+/// Service for handling email verification flows
+/// </summary>
+public interface IEmailVerificationService
+{
+    /// <summary>
+    /// Generates a new verification token for a user
+    /// </summary>
+    /// <param name="email">The email address to generate token for</param>
+    /// <returns>The generated verification token</returns>
+    Task<EmailVerificationToken> GenerateVerificationTokenAsync(string email);
+
+    /// <summary>
+    /// Verifies an email using the provided token
+    /// </summary>
+    /// <param name="token">The verification token</param>
+    /// <returns>Verification result</returns>
+    Task<VerifyEmailResponse> VerifyEmailAsync(string token);
+
+    /// <summary>
+    /// Resends a verification email to a user
+    /// </summary>
+    /// <param name="email">The email address to send verification to</param>
+    /// <returns>Resend result</returns>
+    Task<ResendVerificationResponse> ResendVerificationEmailAsync(string email);
+
+    /// <summary>
+    /// Gets the verification status for a user
+    /// </summary>
+    /// <param name="email">The email address to check</param>
+    /// <returns>Verification status</returns>
+    Task<VerificationStatusResponse> GetVerificationStatusAsync(string email);
+
+    /// <summary>
+    /// Clean up expired verification tokens
+    /// </summary>
+    /// <returns>Number of expired tokens cleaned up</returns>
+    Task<int> CleanupExpiredTokensAsync();
+}
+
+/// <summary>
+/// Response model for resending verification email
+/// </summary>
+public class ResendVerificationResponse
+{
+    /// <summary>
+    /// Gets or sets a value indicating whether the resend was successful
+    /// </summary>
+    public bool Success { get; set; }
+
+    /// <summary>
+    /// Gets or sets an error message if resend failed
+    /// </summary>
+    public string? ErrorMessage { get; set; }
+
+    /// <summary>
+    /// Gets or sets the new verification token (if successful)
+    /// </summary>
+    public string? NewToken { get; set; }
+
+    /// <summary>
+    /// Gets or sets a success message if resend succeeded
+    /// </summary>
+    public string? SuccessMessage { get; set; }
+}
+
+/// <summary>
+/// Response model for verification status
+/// </summary>
+public class VerificationStatusResponse
+{
+    /// <summary>
+    /// Gets or sets a value indicating whether the email is verified
+    /// </summary>
+    public bool IsVerified { get; set; }
+
+    /// <summary>
+    /// Gets or sets the verification status message
+    /// </summary>
+    public string Status { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the email address
+    /// </summary>
+    public string Email { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets a value indicating whether there's a pending verification
+    /// </summary>
+    public bool HasPendingVerification { get; set; }
+
+    /// <summary>
+    /// Gets or sets the expiration time of the current verification token (if any)
+    /// </summary>
+    public DateTime? TokenExpiresAt { get; set; }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Application/Services/PasswordResetService.cs b/backend/src/Execora.Application/Services/PasswordResetService.cs
index 5fa5cfa..1b8d41f 100644
--- a/backend/src/Execora.Application/Services/PasswordResetService.cs
+++ b/backend/src/Execora.Application/Services/PasswordResetService.cs
@@ -6,6 +6,7 @@
 using Execora.Auth.Services;
 using Microsoft.AspNetCore.Http;
 using System.Security.Cryptography;
+using Execora.Core.Enums;
 
 namespace Execora.Application.Services;
 
@@ -45,7 +46,7 @@ public async Task ForgotPasswordAsync(ForgotPasswordRequest request)
         // Check if user exists with this email
         var user = await _userRepository.GetByEmailAsync(request.Email);
 
-        if (user == null || !user.IsEmailVerified || !user.IsActive)
+        if (user == null || !user.EmailVerified || !user.IsActive)
         {
             // For security, don't reveal if the email exists
             // Log the attempt but don't send email
@@ -181,7 +182,7 @@ public async Task ChangePasswordAsync(Guid userId, ChangePasswordRequest request
         }
 
         // Verify current password
-        var isCurrentPasswordValid = await _passwordHasher.VerifyPassword(
+        var isCurrentPasswordValid = _passwordHasher.VerifyPassword(
             request.CurrentPassword,
             user.PasswordHash);
 
@@ -203,7 +204,9 @@ await _auditLogService.LogSecurityEventAsync(
         ValidatePassword(request.NewPassword);
 
         // Check if password is in history (last 5 passwords)
-        if (await _passwordHasher.IsPasswordInHistory(user.Id, request.NewPassword))
+        var passwordHistory = await GetPasswordHistoryAsync(user.Id, 5);
+        var newHash = _passwordHasher.HashPassword(request.NewPassword);
+        if (_passwordHasher.IsPasswordInHistory(newHash, passwordHistory))
         {
             throw new InvalidOperationException("Cannot reuse a recent password");
         }
diff --git a/backend/src/Execora.Application/Services/RegistrationService.cs b/backend/src/Execora.Application/Services/RegistrationService.cs
index 6b6f54f..5900a40 100644
--- a/backend/src/Execora.Application/Services/RegistrationService.cs
+++ b/backend/src/Execora.Application/Services/RegistrationService.cs
@@ -80,7 +80,7 @@ public async Task<RegisterResponse> RegisterAsync(RegisterRequest request, Cance
             PasswordHash = passwordHash,
             FirstName = request.FirstName,
             LastName = request.LastName,
-            EmailConfirmed = false // Email verification to be implemented in Phase 4
+            EmailVerified = false // Email verification to be implemented in Phase 4
         };
 
         // Create tenant
@@ -141,7 +141,7 @@ public async Task<bool> VerifyEmailAsync(Guid userId, string token, Cancellation
 
         // TODO: Implement email verification token validation in Phase 4
         // For now, just mark email as confirmed
-        user.EmailConfirmed = true;
+        user.EmailVerified = true;
         await _userRepository.UpdateAsync(user, cancellationToken);
 
         // Log verification
@@ -166,7 +166,7 @@ await _auditLogService.LogStateChangeAsync(
     public async Task ResendVerificationEmailAsync(Guid userId, CancellationToken cancellationToken = default)
     {
         var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
-        if (user == null || user.EmailConfirmed)
+        if (user == null || user.EmailVerified)
         {
             return;
         }
@@ -243,7 +243,7 @@ await _emailService.SendEmailVerificationAsync(
             LastName = user.LastName,
             OrganizationName = tenant.Name,
             Role = tenantUser.Role.ToString(),
-            EmailConfirmed = user.EmailConfirmed,
+            EmailVerified = user.EmailVerified,
             EmailVerificationToken = emailVerificationToken
         };
     }
@@ -274,4 +274,28 @@ private string GenerateEmailVerificationToken(Guid userId)
         // For now, generate a simple token
         return Convert.ToBase64String(Guid.NewGuid().ToByteArray());
     }
+
+    /// <summary>
+    /// Get verification status for a user
+    /// </summary>
+    public async Task<VerificationStatusResponse> GetVerificationStatusAsync(string email, CancellationToken cancellationToken = default)
+    {
+        var user = await _userRepository.GetByEmailAsync(email, cancellationToken);
+        if (user == null)
+        {
+            return new VerificationStatusResponse
+            {
+                IsVerified = false,
+                Status = "User not found",
+                Email = email
+            };
+        }
+
+        return new VerificationStatusResponse
+        {
+            IsVerified = user.EmailVerified,
+            Email = email,
+            Status = user.EmailVerified ? "Email is already verified" : "Email verification pending"
+        };
+    }
 }
\ No newline at end of file
diff --git a/backend/src/Execora.Core/Entities/EmailVerificationToken.cs b/backend/src/Execora.Core/Entities/EmailVerificationToken.cs
new file mode 100644
index 0000000..c74f1e5
--- /dev/null
+++ b/backend/src/Execora.Core/Entities/EmailVerificationToken.cs
@@ -0,0 +1,46 @@
+namespace Execora.Core.Entities;
+
+/// <summary>
+/// Represents an email verification token for user account activation
+/// </summary>
+public class EmailVerificationToken : BaseEntity
+{
+    /// <summary>
+    /// Gets or sets the email address this token is associated with
+    /// </summary>
+    public required string Email { get; set; }
+
+    /// <summary>
+    /// Gets or sets the verification token (hashed for security)
+    /// </summary>
+    public required string Token { get; set; }
+
+    /// <summary>
+    /// Gets or sets the expiration time for this verification token
+    /// </summary>
+    public required DateTime ExpiresAt { get; set; }
+
+    /// <summary>
+    /// Gets or sets a value indicating whether this token has been used
+    /// </summary>
+    public bool IsUsed { get; set; }
+
+    /// <summary>
+    /// Gets or sets the user ID associated with this token (nullable for invitation flows)
+    /// </summary>
+    public Guid? UserId { get; set; }
+
+    /// <summary>
+    /// Gets or sets the tenant ID associated with this token (nullable for invitation flows)
+    /// </summary>
+    public Guid? TenantId { get; set; }
+
+    /// <summary>
+    /// Gets or sets the date when the token was used
+    /// </summary>
+    public DateTime? UsedAt { get; set; }
+
+    // Navigation properties
+    public User? User { get; set; }
+    public Tenant? Tenant { get; set; }
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Core/Entities/User.cs b/backend/src/Execora.Core/Entities/User.cs
index 52bfc7f..c4575db 100644
--- a/backend/src/Execora.Core/Entities/User.cs
+++ b/backend/src/Execora.Core/Entities/User.cs
@@ -15,7 +15,17 @@ public class User : BaseEntity
     /// <summary>
     /// Email verification status
     /// </summary>
-    public bool EmailConfirmed { get; set; }
+    public bool EmailVerified { get; set; }
+
+    /// <summary>
+    /// Email verification token (for storing verification tokens)
+    /// </summary>
+    public string? EmailVerificationToken { get; set; }
+
+    /// <summary>
+    /// Email verification token expiration time
+    /// </summary>
+    public DateTime? EmailVerificationTokenExpiresAt { get; set; }
 
     /// <summary>
     /// Mobile number
diff --git a/backend/src/Execora.Core/Interfaces/IEmailVerificationTokenRepository.cs b/backend/src/Execora.Core/Interfaces/IEmailVerificationTokenRepository.cs
new file mode 100644
index 0000000..f4b22ea
--- /dev/null
+++ b/backend/src/Execora.Core/Interfaces/IEmailVerificationTokenRepository.cs
@@ -0,0 +1,68 @@
+using Execora.Core.Entities;
+
+namespace Execora.Core.Interfaces;
+
+/// <summary>
+/// Repository interface for managing email verification tokens
+/// </summary>
+public interface IEmailVerificationTokenRepository
+{
+    /// <summary>
+    /// Creates a new email verification token
+    /// </summary>
+    /// <param name="token">The email verification token to create</param>
+    /// <returns>The created token</returns>
+    Task<EmailVerificationToken> CreateAsync(EmailVerificationToken token);
+
+    /// <summary>
+    /// Gets a verification token by its value (token string)
+    /// </summary>
+    /// <param name="token">The token value to search for</param>
+    /// <returns>The verification token if found, null otherwise</returns>
+    Task<EmailVerificationToken?> GetByTokenAsync(string token);
+
+    /// <summary>
+    /// Gets all verification tokens for a specific email address
+    /// </summary>
+    /// <param name="email">The email address</param>
+    /// <returns>List of verification tokens for the email</returns>
+    Task<List<EmailVerificationToken>> GetByEmailAsync(string email);
+
+    /// <summary>
+    /// Gets all verification tokens for a specific user
+    /// </summary>
+    /// <param name="userId">The user ID</param>
+    /// <returns>List of verification tokens for the user</returns>
+    Task<List<EmailVerificationToken>> GetByUserIdAsync(Guid userId);
+
+    /// <summary>
+    /// Updates an existing verification token
+    /// </summary>
+    /// <param name="token">The token to update</param>
+    /// <returns>The updated token</returns>
+    Task<EmailVerificationToken> UpdateAsync(EmailVerificationToken token);
+
+    /// <summary>
+    /// Deletes a verification token
+    /// </summary>
+    /// <param name="token">The token to delete</param>
+    Task DeleteAsync(EmailVerificationToken token);
+
+    /// <summary>
+    /// Deletes all expired verification tokens
+    /// </summary>
+    /// <returns>Number of tokens deleted</returns>
+    Task<int> DeleteExpiredTokensAsync();
+
+    /// <summary>
+    /// Deletes all verification tokens for a specific email address
+    /// </summary>
+    /// <param name="email">The email address</param>
+    Task DeleteByEmailAsync(string email);
+
+    /// <summary>
+    /// Deletes all verification tokens for a specific user
+    /// </summary>
+    /// <param name="userId">The user ID</param>
+    Task DeleteByUserIdAsync(Guid userId);
+}
\ No newline at end of file
diff --git a/backend/src/Execora.Infrastructure/Data/ExecoraDbContext.cs b/backend/src/Execora.Infrastructure/Data/ExecoraDbContext.cs
index 86f25d9..0fdff21 100644
--- a/backend/src/Execora.Infrastructure/Data/ExecoraDbContext.cs
+++ b/backend/src/Execora.Infrastructure/Data/ExecoraDbContext.cs
@@ -33,6 +33,7 @@ public ExecoraDbContext(DbContextOptions<ExecoraDbContext> options)
     public DbSet<AuditLog> AuditLogs { get; set; } = null!;
     public DbSet<PasswordHistory> PasswordHistory { get; set; } = null!;
     public DbSet<PasswordResetToken> PasswordResetTokens { get; set; } = null!;
+    public DbSet<EmailVerificationToken> EmailVerificationTokens { get; set; } = null!;
 
     #endregion
 
@@ -193,6 +194,20 @@ private void ConfigureEntities(ModelBuilder builder)
             .HasForeignKey(prt => prt.UserId)
             .OnDelete(DeleteBehavior.Cascade);
 
+        // EmailVerificationToken - User (Many-to-One, optional)
+        builder.Entity<EmailVerificationToken>()
+            .HasOne(evt => evt.User)
+            .WithMany()
+            .HasForeignKey(evt => evt.UserId)
+            .OnDelete(DeleteBehavior.Cascade);
+
+        // EmailVerificationToken - Tenant (Many-to-One, optional)
+        builder.Entity<EmailVerificationToken>()
+            .HasOne(evt => evt.Tenant)
+            .WithMany()
+            .HasForeignKey(evt => evt.TenantId)
+            .OnDelete(DeleteBehavior.Cascade);
+
         // Unique constraint on TenantUser combination
         builder.Entity<TenantUser>()
             .HasIndex(tu => new { tu.TenantId, tu.UserId })
@@ -277,6 +292,28 @@ private void ConfigureIndexes(ModelBuilder builder)
             .HasIndex(prt => prt.IsUsed)
             .HasDatabaseName("IX_PasswordResetTokens_IsUsed");
 
+        // EmailVerificationToken indexes
+        builder.Entity<EmailVerificationToken>()
+            .HasIndex(evt => evt.Token)
+            .IsUnique()
+            .HasDatabaseName("IX_EmailVerificationTokens_Token");
+
+        builder.Entity<EmailVerificationToken>()
+            .HasIndex(evt => evt.Email)
+            .HasDatabaseName("IX_EmailVerificationTokens_Email");
+
+        builder.Entity<EmailVerificationToken>()
+            .HasIndex(evt => evt.UserId)
+            .HasDatabaseName("IX_EmailVerificationTokens_UserId");
+
+        builder.Entity<EmailVerificationToken>()
+            .HasIndex(evt => evt.ExpiresAt)
+            .HasDatabaseName("IX_EmailVerificationTokens_ExpiresAt");
+
+        builder.Entity<EmailVerificationToken>()
+            .HasIndex(evt => evt.IsUsed)
+            .HasDatabaseName("IX_EmailVerificationTokens_IsUsed");
+
         // AuditLog indexes
         builder.Entity<AuditLog>()
             .HasIndex(al => new { al.TenantId, al.ChangedAt })
diff --git a/backend/src/Execora.Infrastructure/Repositories/EmailVerificationTokenRepository.cs b/backend/src/Execora.Infrastructure/Repositories/EmailVerificationTokenRepository.cs
new file mode 100644
index 0000000..c743609
--- /dev/null
+++ b/backend/src/Execora.Infrastructure/Repositories/EmailVerificationTokenRepository.cs
@@ -0,0 +1,91 @@
+using Execora.Core.Entities;
+using Execora.Core.Interfaces;
+using Execora.Infrastructure.Data;
+using Microsoft.EntityFrameworkCore;
+
+namespace Execora.Infrastructure.Repositories;
+
+/// <summary>
+/// Repository implementation for email verification tokens
+/// </summary>
+public class EmailVerificationTokenRepository : IEmailVerificationTokenRepository
+{
+    private readonly ExecoraDbContext _context;
+
+    public EmailVerificationTokenRepository(ExecoraDbContext context)
+    {
+        _context = context;
+    }
+
+    public async Task<EmailVerificationToken> CreateAsync(EmailVerificationToken token)
+    {
+        _context.EmailVerificationTokens.Add(token);
+        await _context.SaveChangesAsync();
+        return token;
+    }
+
+    public async Task<EmailVerificationToken?> GetByTokenAsync(string token)
+    {
+        return await _context.EmailVerificationTokens
+            .FirstOrDefaultAsync(t => t.Token == token);
+    }
+
+    public async Task<List<EmailVerificationToken>> GetByEmailAsync(string email)
+    {
+        return await _context.EmailVerificationTokens
+            .Where(t => t.Email == email)
+            .OrderByDescending(t => t.CreatedAt)
+            .ToListAsync();
+    }
+
+    public async Task<List<EmailVerificationToken>> GetByUserIdAsync(Guid userId)
+    {
+        return await _context.EmailVerificationTokens
+            .Where(t => t.UserId == userId)
+            .OrderByDescending(t => t.CreatedAt)
+            .ToListAsync();
+    }
+
+    public async Task<EmailVerificationToken> UpdateAsync(EmailVerificationToken token)
+    {
+        _context.Entry(token).State = EntityState.Modified;
+        await _context.SaveChangesAsync();
+        return token;
+    }
+
+    public async Task DeleteAsync(EmailVerificationToken token)
+    {
+        _context.EmailVerificationTokens.Remove(token);
+        await _context.SaveChangesAsync();
+    }
+
+    public async Task<int> DeleteExpiredTokensAsync()
+    {
+        var expiredTokens = await _context.EmailVerificationTokens
+            .Where(t => t.ExpiresAt <= DateTime.UtcNow)
+            .ToListAsync();
+
+        _context.EmailVerificationTokens.RemoveRange(expiredTokens);
+        return await _context.SaveChangesAsync();
+    }
+
+    public async Task DeleteByEmailAsync(string email)
+    {
+        var tokens = await _context.EmailVerificationTokens
+            .Where(t => t.Email == email)
+            .ToListAsync();
+
+        _context.EmailVerificationTokens.RemoveRange(tokens);
+        await _context.SaveChangesAsync();
+    }
+
+    public async Task DeleteByUserIdAsync(Guid userId)
+    {
+        var tokens = await _context.EmailVerificationTokens
+            .Where(t => t.UserId == userId)
+            .ToListAsync();
+
+        _context.EmailVerificationTokens.RemoveRange(tokens);
+        await _context.SaveChangesAsync();
+    }
+}
\ No newline at end of file
diff --git a/backend/tests/Execora.Tests.Unit/Services/EmailVerificationServiceTests.cs b/backend/tests/Execora.Tests.Unit/Services/EmailVerificationServiceTests.cs
new file mode 100644
index 0000000..f398404
--- /dev/null
+++ b/backend/tests/Execora.Tests.Unit/Services/EmailVerificationServiceTests.cs
@@ -0,0 +1,297 @@
+using Execora.Application.Services;
+using Execora.Core.Entities;
+using Execora.Core.Enums;
+using Execora.Infrastructure.Repositories;
+using Microsoft.Extensions.Logging;
+using Moq;
+using Xunit;
+using Execora.Core.Interfaces;
+using Execora.Infrastructure.Services.Email;
+
+namespace Execora.Tests.Unit.Services;
+
+public class EmailVerificationServiceTests
+{
+    private Mock<IUserRepository> _userRepositoryMock = null!;
+    private Mock<IEmailVerificationTokenRepository> _tokenRepositoryMock = null!;
+    private Mock<IEmailService> _emailServiceMock = null!;
+    private Mock<ILogger<EmailVerificationService>> _loggerMock = null!;
+    private EmailVerificationService _service = null!;
+
+    public EmailVerificationServiceTests()
+    {
+        _userRepositoryMock = new Mock<IUserRepository>();
+        _tokenRepositoryMock = new Mock<IEmailVerificationTokenRepository>();
+        _emailServiceMock = new Mock<IEmailService>();
+        _loggerMock = new Mock<ILogger<EmailVerificationService>>();
+        _service = new EmailVerificationService(
+            _userRepositoryMock.Object,
+            _tokenRepositoryMock.Object,
+            _emailServiceMock.Object,
+            _loggerMock.Object);
+    }
+
+    [Fact]
+    public async Task GenerateVerificationTokenAsync_ShouldGenerateUniqueToken_WhenUserExists()
+    {
+        // Arrange
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = false,
+            EmailVerificationToken = null,
+            EmailVerificationTokenExpiresAt = null
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        // Act
+        var token = await _service.GenerateVerificationTokenAsync("test@example.com");
+
+        // Assert
+        Assert.NotNull(token);
+        // EmailVerificationToken doesn't have an Id property in the current implementation
+        Assert.Equal("test@example.com", token.Email);
+        Assert.False(token.IsUsed);
+        Assert.True(token.ExpiresAt > DateTime.UtcNow);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.Is<User>(u => u.EmailVerificationToken == token.Token)),
+            Times.Once);
+    }
+
+    [Fact]
+    public async Task GenerateVerificationTokenAsync_ShouldThrowException_WhenUserDoesNotExist()
+    {
+        // Arrange
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync("test@example.com"))
+            .ReturnsAsync((User?)null);
+
+        // Act & Assert
+        await Assert.ThrowsAsync<KeyNotFoundException>(
+            async () => await _service.GenerateVerificationTokenAsync("test@example.com"));
+    }
+
+    [Fact]
+    public async Task VerifyEmailAsync_ShouldMarkUserAsVerified_WhenTokenIsValid()
+    {
+        // Arrange
+        var token = new EmailVerificationToken
+        {
+            Token = "valid-token-123",
+            Email = "test@example.com",
+            ExpiresAt = DateTime.UtcNow.AddHours(1),
+            IsUsed = false
+        };
+
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = false,
+            EmailVerificationToken = "valid-token-123",
+            EmailVerificationTokenExpiresAt = DateTime.UtcNow.AddHours(1)
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        _userRepositoryMock.Setup(x => x.GetVerificationTokenAsync("valid-token-123"))
+            .ReturnsAsync(token);
+
+        // Act
+        var result = await _service.VerifyEmailAsync("valid-token-123");
+
+        // Assert
+        Assert.True(result.Success);
+        Assert.True(result.EmailVerified);
+        Assert.Null(result.ErrorMessage);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.Is<User>(u => u.EmailVerified && u.EmailVerificationToken == null)),
+            Times.Once);
+    }
+
+    [Fact]
+    public async Task VerifyEmailAsync_ShouldReturnError_WhenTokenIsExpired()
+    {
+        // Arrange
+        var token = new EmailVerificationToken
+        {
+            Token = "expired-token",
+            Email = "test@example.com",
+            ExpiresAt = DateTime.UtcNow.AddHours(-1),
+            IsUsed = false
+        };
+
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = false,
+            EmailVerificationToken = "expired-token",
+            EmailVerificationTokenExpiresAt = DateTime.UtcNow.AddHours(-1)
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        _userRepositoryMock.Setup(x => x.GetVerificationTokenAsync("expired-token"))
+            .ReturnsAsync(token);
+
+        // Act
+        var result = await _service.VerifyEmailAsync("expired-token");
+
+        // Assert
+        Assert.False(result.Success);
+        Assert.False(result.EmailVerified);
+        Assert.Equal("Verification token has expired", result.ErrorMessage);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.IsAny<User>()),
+            Times.Never);
+    }
+
+    [Fact]
+    public async Task VerifyEmailAsync_ShouldReturnError_WhenTokenIsAlreadyUsed()
+    {
+        // Arrange
+        var token = new EmailVerificationToken
+        {
+            Token = "used-token",
+            Email = "test@example.com",
+            ExpiresAt = DateTime.UtcNow.AddHours(1),
+            IsUsed = true
+        };
+
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = false,
+            EmailVerificationToken = "used-token",
+            EmailVerificationTokenExpiresAt = DateTime.UtcNow.AddHours(1)
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        _userRepositoryMock.Setup(x => x.GetVerificationTokenAsync("used-token"))
+            .ReturnsAsync(token);
+
+        // Act
+        var result = await _service.VerifyEmailAsync("used-token");
+
+        // Assert
+        Assert.False(result.Success);
+        Assert.False(result.EmailVerified);
+        Assert.Equal("Verification token has already been used", result.ErrorMessage);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.IsAny<User>()),
+            Times.Never);
+    }
+
+    [Fact]
+    public async Task VerifyEmailAsync_ShouldReturnError_WhenUserNotFound()
+    {
+        // Arrange
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync("test@example.com"))
+            .ReturnsAsync((User?)null);
+
+        // Act
+        var result = await _service.VerifyEmailAsync("any-token");
+
+        // Assert
+        Assert.False(result.Success);
+        Assert.False(result.EmailVerified);
+        Assert.Equal("User not found", result.ErrorMessage);
+    }
+
+    [Fact]
+    public async Task ResendVerificationEmailAsync_ShouldGenerateNewToken_WhenUserExistsAndNotVerified()
+    {
+        // Arrange
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = false,
+            EmailVerificationToken = "old-token",
+            EmailVerificationTokenExpiresAt = DateTime.UtcNow.AddHours(-1)
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        // Act
+        var result = await _service.ResendVerificationEmailAsync("test@example.com");
+
+        // Assert
+        Assert.True(result.Success);
+        Assert.NotNull(result.NewToken);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.Is<User>(u => u.EmailVerificationToken != "old-token")),
+            Times.Once);
+    }
+
+    [Fact]
+    public async Task ResendVerificationEmailAsync_ShouldReturnError_WhenUserAlreadyVerified()
+    {
+        // Arrange
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = true
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        // Act
+        var result = await _service.ResendVerificationEmailAsync("test@example.com");
+
+        // Assert
+        Assert.False(result.Success);
+        Assert.Equal("Email is already verified", result.ErrorMessage);
+        _userRepositoryMock.Verify(
+            x => x.UpdateAsync(It.IsAny<User>()),
+            Times.Never);
+    }
+
+    [Fact]
+    public async Task ResendVerificationEmailAsync_ShReturnError_WhenUserNotFound()
+    {
+        // Arrange
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync("test@example.com"))
+            .ReturnsAsync((User?)null);
+
+        // Act
+        var result = await _service.ResendVerificationEmailAsync("test@example.com");
+
+        // Assert
+        Assert.False(result.Success);
+        Assert.Equal("User not found", result.ErrorMessage);
+    }
+
+    [Fact]
+    public async Task GetVerificationStatusAsync_ShouldReturnCorrectStatus_WhenUserExists()
+    {
+        // Arrange
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            Email = "test@example.com",
+            EmailVerified = true
+        };
+
+        _userRepositoryMock.Setup(x => x.GetByEmailAsync(It.IsAny<string>()))
+            .ReturnsAsync((string email) => email == "test@example.com" ? user : null);
+
+        // Act
+        var result = await _service.GetVerificationStatusAsync("test@example.com");
+
+        // Assert
+        Assert.True(result.IsVerified);
+        Assert.Equal("Email is already verified", result.Status);
+    }
+}
\ No newline at end of file
diff --git a/frontend/src/app/app.routes.ts b/frontend/src/app/app.routes.ts
index dba27f4..5e69308 100644
--- a/frontend/src/app/app.routes.ts
+++ b/frontend/src/app/app.routes.ts
@@ -1,9 +1,25 @@
 import { Routes } from '@angular/router';
+import { LoginComponent } from './features/auth/login/login.component';
+import { RegisterComponent } from './features/auth/register/register.component';
 import { ForgotPasswordComponent } from './features/auth/forgot-password/forgot-password.component';
 import { ResetPasswordComponent } from './features/auth/reset-password/reset-password.component';
 import { ChangePasswordComponent } from './features/auth/change-password/change-password.component';
+import { DashboardComponent } from './features/dashboard/dashboard.component';
+import { VerifyEmailComponent } from './features/auth/verify-email/verify-email.component';
 
 export const routes: Routes = [
+  {
+    path: 'login',
+    component: LoginComponent
+  },
+  {
+    path: 'register',
+    component: RegisterComponent
+  },
+  {
+    path: 'dashboard',
+    component: DashboardComponent
+  },
   {
     path: 'auth/change-password',
     component: ChangePasswordComponent
@@ -15,5 +31,14 @@ export const routes: Routes = [
   {
     path: 'auth/reset-password',
     component: ResetPasswordComponent
+  },
+  {
+    path: 'verify-email',
+    component: VerifyEmailComponent
+  },
+  {
+    path: '',
+    redirectTo: '/login',
+    pathMatch: 'full'
   }
 ];
diff --git a/frontend/src/app/core/models/auth.model.ts b/frontend/src/app/core/models/auth.model.ts
index 4220676..0d3ca7b 100644
--- a/frontend/src/app/core/models/auth.model.ts
+++ b/frontend/src/app/core/models/auth.model.ts
@@ -60,8 +60,12 @@ export interface RegisterResponse {
   userId: string;
   tenantId: string;
   email: string;
-  requiresEmailVerification: boolean;
-  message: string;
+  firstName: string;
+  lastName: string;
+  organizationName: string;
+  role: string;
+  emailVerified: boolean;
+  emailVerificationToken?: string;
 }
 
 /**
@@ -117,6 +121,17 @@ export interface ResendVerificationRequest {
   email: string;
 }
 
+/**
+ * Verify email response
+ */
+export interface VerifyEmailResponse {
+  success: boolean;
+  emailVerified: boolean;
+  email?: string;
+  errorMessage?: string;
+  successMessage?: string;
+}
+
 /**
  * Invitation status
  */
diff --git a/frontend/src/app/core/models/user.model.ts b/frontend/src/app/core/models/user.model.ts
index ddde586..acaddc4 100644
--- a/frontend/src/app/core/models/user.model.ts
+++ b/frontend/src/app/core/models/user.model.ts
@@ -6,7 +6,7 @@ import { TenantRole, Tenant } from './tenant.model';
 export interface User {
   id: string;
   email: string;
-  emailConfirmed: boolean;
+  emailVerified: boolean;
   phoneNumber?: string | null;
   phoneNumberConfirmed: boolean;
   firstName: string;
diff --git a/frontend/src/app/core/providers/ng-zorro.providers.ts b/frontend/src/app/core/providers/ng-zorro.providers.ts
new file mode 100644
index 0000000..1a20108
--- /dev/null
+++ b/frontend/src/app/core/providers/ng-zorro.providers.ts
@@ -0,0 +1,18 @@
+import { Provider } from '@angular/core';
+import { NzMessageService } from 'ng-zorro-antd/message';
+import { NzCardModule } from 'ng-zorro-antd/card';
+import { NzButtonModule } from 'ng-zorro-antd/button';
+import { NzIconModule } from 'ng-zorro-antd/icon';
+import { NzAlertModule } from 'ng-zorro-antd/alert';
+import { NzSpinModule } from 'ng-zorro-antd/spin';
+import { NzInputModule } from 'ng-zorro-antd/input';
+
+export const ngZorroProviders: Provider[] = [
+  NzMessageService,
+  NzCardModule,
+  NzButtonModule,
+  NzIconModule,
+  NzAlertModule,
+  NzSpinModule,
+  NzInputModule
+];
\ No newline at end of file
diff --git a/frontend/src/app/core/services/auth.service.ts b/frontend/src/app/core/services/auth.service.ts
index ffc8524..c8611dc 100644
--- a/frontend/src/app/core/services/auth.service.ts
+++ b/frontend/src/app/core/services/auth.service.ts
@@ -3,7 +3,7 @@ import { BehaviorSubject, Observable, of, throwError } from 'rxjs';
 import { map, switchMap, tap, catchError } from 'rxjs/operators';
 import { ApiService } from './api.service';
 import { User, UserProfile, Tenant, TenantRole } from '../models';
-import { RegisterRequest, RegisterResponse } from '../models/auth.model';
+import { RegisterRequest, RegisterResponse, VerifyEmailRequest, ResendVerificationRequest, VerifyEmailResponse } from '../models/auth.model';
 
 /**
  * Authentication tokens
@@ -164,6 +164,20 @@ export class AuthService {
     return this.apiService.post('/auth/password/change-password', data);
   }
 
+  /**
+   * Verify email using token
+   */
+  verifyEmail(token: string): Observable<VerifyEmailResponse> {
+    return this.apiService.post<VerifyEmailResponse>('/auth/verify-email', { token });
+  }
+
+  /**
+   * Resend email verification
+   */
+  resendVerification(email: string): Observable<any> {
+    return this.apiService.post('/auth/resend-verification', { email });
+  }
+
   /**
    * Refresh access token
    */
diff --git a/frontend/src/app/features/auth/login/login.component.html b/frontend/src/app/features/auth/login/login.component.html
new file mode 100644
index 0000000..c293580
--- /dev/null
+++ b/frontend/src/app/features/auth/login/login.component.html
@@ -0,0 +1,72 @@
+<div class="login-container">
+  <div class="login-box">
+    <div class="login-header">
+      <h1>Welcome Back</h1>
+      <p>Sign in to your account to continue</p>
+    </div>
+
+    <form nz-form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
+      <nz-form-item>
+        <nz-form-control nzErrorTip="Please enter a valid email address">
+          <label nz-form-label>Email</label>
+          <nz-form-control>
+            <input
+              nz-input
+              type="email"
+              formControlName="email"
+              placeholder="Enter your email"
+              (keypress)="onKeyPress($event)"
+            />
+          </nz-form-control>
+        </nz-form-control>
+      </nz-form-item>
+
+      <nz-form-item>
+        <nz-form-control nzErrorTip="Password must be at least 8 characters long">
+          <label nz-form-label>Password</label>
+          <nz-form-control>
+            <input
+              nz-input
+              type="password"
+              formControlName="password"
+              placeholder="Enter your password"
+              (keypress)="onKeyPress($event)"
+            />
+          </nz-form-control>
+        </nz-form-control>
+      </nz-form-item>
+
+      <nz-form-item>
+        <div class="form-footer">
+          <label nz-checkbox formControlName="rememberMe">Remember me</label>
+          <a href="javascript:;" (click)="forgotPassword()">Forgot Password?</a>
+        </div>
+      </nz-form-item>
+
+      <nz-form-item>
+        <button
+          nz-button
+          type="submit"
+          [nzLoading]="loading"
+          [nzType]="'primary'"
+          [nzBlock]="true"
+        >
+          Sign In
+        </button>
+      </nz-form-item>
+    </form>
+
+    <div class="login-divider">
+      <span>Don't have an account?</span>
+    </div>
+
+    <button
+      nz-button
+      [nzType]="'default'"
+      [nzBlock]="true"
+      (click)="goToRegister()"
+    >
+      Create Account
+    </button>
+  </div>
+</div>
\ No newline at end of file
diff --git a/frontend/src/app/features/auth/login/login.component.scss b/frontend/src/app/features/auth/login/login.component.scss
new file mode 100644
index 0000000..fc24745
--- /dev/null
+++ b/frontend/src/app/features/auth/login/login.component.scss
@@ -0,0 +1,126 @@
+.login-container {
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  min-height: 100vh;
+  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
+  padding: 20px;
+
+  .login-box {
+    background: white;
+    border-radius: 8px;
+    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
+    padding: 40px;
+    width: 100%;
+    max-width: 400px;
+
+    .login-header {
+      text-align: center;
+      margin-bottom: 30px;
+
+      h1 {
+        font-size: 28px;
+        font-weight: 600;
+        color: #1a202c;
+        margin-bottom: 8px;
+      }
+
+      p {
+        color: #718096;
+        font-size: 14px;
+      }
+    }
+
+    form {
+      nz-form-item {
+        margin-bottom: 20px;
+
+        label {
+          font-weight: 500;
+          color: #374151;
+          margin-bottom: 8px;
+          display: block;
+        }
+
+        input {
+          border: 1px solid #e5e7eb;
+          border-radius: 6px;
+          padding: 10px 12px;
+          font-size: 14px;
+          width: 100%;
+          transition: all 0.3s;
+
+          &:hover {
+            border-color: #6366f1;
+          }
+
+          &:focus {
+            outline: none;
+            border-color: #6366f1;
+            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
+          }
+        }
+      }
+
+      .form-footer {
+        display: flex;
+        justify-content: space-between;
+        align-items: center;
+        font-size: 14px;
+
+        nz-checkbox {
+          color: #374151;
+        }
+
+        a {
+          color: #6366f1;
+          text-decoration: none;
+          font-weight: 500;
+
+          &:hover {
+            text-decoration: underline;
+          }
+        }
+      }
+
+      button {
+        height: 44px;
+        font-weight: 500;
+        font-size: 16px;
+      }
+    }
+
+    .login-divider {
+      text-align: center;
+      margin: 20px 0;
+      position: relative;
+
+      &::before {
+        content: '';
+        position: absolute;
+        top: 50%;
+        left: 0;
+        right: 0;
+        height: 1px;
+        background: #e5e7eb;
+      }
+
+      span {
+        background: white;
+        padding: 0 15px;
+        color: #9ca3af;
+        font-size: 14px;
+        position: relative;
+      }
+    }
+  }
+}
+
+// Responsive design
+@media (max-width: 480px) {
+  .login-container {
+    .login-box {
+      padding: 30px 20px;
+    }
+  }
+}
\ No newline at end of file
diff --git a/frontend/src/app/features/auth/login/login.component.ts b/frontend/src/app/features/auth/login/login.component.ts
new file mode 100644
index 0000000..954f787
--- /dev/null
+++ b/frontend/src/app/features/auth/login/login.component.ts
@@ -0,0 +1,114 @@
+import { Component, OnInit, OnDestroy } from '@angular/core';
+import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
+import { Router } from '@angular/router';
+import { Subscription } from 'rxjs';
+import { tap } from 'rxjs/operators';
+import { MatSnackBar } from '@angular/material/snack-bar';
+import { AuthService } from '../../../core/services/auth.service';
+import { LoginRequest } from '../../../core/models/auth.model';
+import { User } from '../../../core/models/user.model';
+
+@Component({
+  selector: 'app-login',
+  standalone: true,
+  imports: [],
+  templateUrl: './login.component.html',
+  styleUrls: ['./login.component.scss']
+})
+export class LoginComponent implements OnInit, OnDestroy {
+  loginForm: FormGroup;
+  loading = false;
+  submitted = false;
+  rememberMe = false;
+
+  private subscription: Subscription = new Subscription();
+
+  constructor(
+    private fb: FormBuilder,
+    private router: Router,
+    private message: NzMessageService,
+    private authService: AuthService
+  ) {
+    this.loginForm = this.fb.group({
+      email: ['', [
+        Validators.required,
+        Validators.email,
+        Validators.maxLength(255)
+      ]],
+      password: ['', [
+        Validators.required,
+        Validators.minLength(8)
+      ]]
+    });
+  }
+
+  ngOnInit(): void {
+    // Check if user is already logged in
+    if (localStorage.getItem('execora_access_token')) {
+      this.router.navigate(['/dashboard']);
+    }
+  }
+
+  ngOnDestroy(): void {
+    this.subscription.unsubscribe();
+  }
+
+  // Getter for easy access to form controls
+  get f(): { [key: string]: AbstractControl } {
+    return this.loginForm.controls;
+  }
+
+  // Submit login form
+  onSubmit(): void {
+    this.submitted = true;
+
+    // Stop here if form is invalid
+    if (this.loginForm.invalid) {
+      return;
+    }
+
+    this.loading = true;
+
+    // Call API to login user
+    const loginData: LoginRequest = this.loginForm.value;
+
+    const subscription = this.authService.login(loginData).pipe(
+      tap((user: User) => {
+        // The auth service already stores the tokens and user data
+        if (this.rememberMe) {
+          localStorage.setItem('execora_remember_me', 'true');
+        }
+      })
+    ).subscribe({
+      next: () => {
+        this.message.success('Login successful!');
+        // Redirect to dashboard
+        this.router.navigate(['/dashboard']);
+      },
+      error: (error: any) => {
+        this.loading = false;
+        this.message.error(error?.error?.detail || 'Login failed. Please check your credentials and try again.');
+        console.error('Login error:', error);
+      }
+    });
+
+    this.subscription.add(subscription);
+  }
+
+  // Forgot password
+  forgotPassword(): void {
+    this.router.navigate(['/auth/forgot-password']);
+  }
+
+  // Go to register
+  goToRegister(): void {
+    this.router.navigate(['/register']);
+  }
+
+  // Handle Enter key press
+  onKeyPress(event: KeyboardEvent): void {
+    if (event.key === 'Enter') {
+      this.onSubmit();
+    }
+  }
+}
\ No newline at end of file
diff --git a/frontend/src/app/features/auth/register/register.component.ts b/frontend/src/app/features/auth/register/register.component.ts
index 71bf4ed..5a34abb 100644
--- a/frontend/src/app/features/auth/register/register.component.ts
+++ b/frontend/src/app/features/auth/register/register.component.ts
@@ -2,15 +2,16 @@ import { Component, OnInit, OnDestroy } from '@angular/core';
 import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
 import { Router } from '@angular/router';
 import { Subscription } from 'rxjs';
+import { CommonModule } from '@angular/common';
 import { NzMessageService } from 'ng-zorro-antd/message';
 import { PasswordStrengthComponent } from '../../../shared/components/password-strength/password-strength.component';
 import { AuthService } from '../../../core/services/auth.service';
-import { RegisterRequest, RegisterResponse } from '../../../core/models';
+import { RegisterRequest, RegisterResponse } from '../../../core/models/auth.model';
 
 @Component({
   selector: 'app-register',
   standalone: true,
-  imports: [PasswordStrengthComponent],
+  imports: [CommonModule, PasswordStrengthComponent],
   templateUrl: './register.component.html',
   styleUrls: ['./register.component.scss']
 })
@@ -93,7 +94,7 @@ export class RegisterComponent implements OnInit, OnDestroy {
     };
 
     // Update password validation rules
-    const passwordControl = this.f.password;
+    const passwordControl = this.f['password'];
     passwordControl.updateValueAndValidity();
   }
 
@@ -121,7 +122,14 @@ export class RegisterComponent implements OnInit, OnDestroy {
     const subscription = this.authService.register(registerData).subscribe({
       next: (response: RegisterResponse) => {
         this.message.success('Registration successful! Please check your email for verification.');
-        this.router.navigate(['/login']);
+
+        // Redirect to verify-email page with email
+        this.router.navigate(['/verify-email'], {
+          queryParams: {
+            email: registerData.email,
+            token: response.emailVerificationToken
+          }
+        });
       },
       error: (error: any) => {
         this.loading = false;
@@ -172,8 +180,8 @@ export class RegisterComponent implements OnInit, OnDestroy {
 
   // Auto-generate organization slug from name (for preview)
   get organizationSlug(): string {
-    if (!this.f.organizationName.value) return '';
-    return this.f.organizationName.value
+    if (!this.f['organizationName'].value) return '';
+    return this.f['organizationName'].value
       .toLowerCase()
       .replace(/[^a-z0-9]/g, '-')
       .replace(/-+/g, '-')
diff --git a/frontend/src/app/features/auth/verify-email/verify-email.component.html b/frontend/src/app/features/auth/verify-email/verify-email.component.html
new file mode 100644
index 0000000..3ae8eba
--- /dev/null
+++ b/frontend/src/app/features/auth/verify-email/verify-email.component.html
@@ -0,0 +1,94 @@
+<div class="verify-email-container">
+  <div class="verify-email-card">
+    <div class="verify-email-header">
+      <span nz-icon nzType="mail" nzTheme="outline" class="verify-email-icon"></span>
+      <h2>Email Verification</h2>
+    </div>
+
+    @if (!isSuccess && !isError) {
+      <div class="verify-email-content">
+        <div class="info-text">
+          <p>Verify your email address to complete your registration</p>
+          @if (email) {
+            <p class="email-display">Email: {{ email }}</p>
+          }
+        </div>
+
+        @if (!token) {
+          <div class="token-prompt">
+            <nz-alert
+              nzType="info"
+              nzDescription="Please check your email for the verification link. If you didn't receive the email, you can request it below."
+            >
+            </nz-alert>
+            <div class="resend-section">
+              <input
+                nz-input
+                placeholder="Enter your email address"
+                [(ngModel)]="email"
+                class="email-input"
+              />
+              <button
+                nz-button
+                nzType="primary"
+                (click)="resendVerification()"
+                [nzLoading]="isLoading"
+                class="resend-button"
+              >
+                <span nz-icon nzType="reload"></span>
+                Resend Verification
+              </button>
+            </div>
+          </div>
+        }
+      </div>
+    }
+
+    @if (isLoading) {
+      <div class="verify-email-loading">
+        <nz-spin nzSize="large"></nz-spin>
+        <p>Verifying your email...</p>
+      </div>
+    }
+
+    @if (isError) {
+      <div class="verify-email-error">
+        <nz-alert
+          nzType="error"
+          nzTitle="Verification Failed"
+          [nzDescription]="errorMessage"
+        >
+        </nz-alert>
+        <div class="error-actions">
+          <button
+            nz-button
+            nzType="primary"
+            (click)="resendVerification()"
+            [nzLoading]="isLoading"
+          >
+            <span nz-icon nzType="reload"></span>
+            Try Again
+          </button>
+          <button
+            nz-button
+            nzType="default"
+            routerLink="/login"
+          >
+            Back to Login
+          </button>
+        </div>
+      </div>
+    }
+
+    @if (isSuccess) {
+      <div class="verify-email-success">
+        <div class="success-result">
+          <span nz-icon nzType="check-circle" nzTheme="fill" class="success-icon"></span>
+          <h3>Email Verified Successfully!</h3>
+          <p>{{ email ? 'Your email ' + email + ' has been verified.' : 'Your email has been verified.' }}</p>
+          <p>You will be redirected to login page shortly...</p>
+        </div>
+      </div>
+    }
+  </div>
+</div>
\ No newline at end of file
diff --git a/frontend/src/app/features/auth/verify-email/verify-email.component.scss b/frontend/src/app/features/auth/verify-email/verify-email.component.scss
new file mode 100644
index 0000000..f6bd0a3
--- /dev/null
+++ b/frontend/src/app/features/auth/verify-email/verify-email.component.scss
@@ -0,0 +1,119 @@
+.verify-email-container {
+  display: flex;
+  justify-content: center;
+  align-items: center;
+  min-height: 100vh;
+  background-color: #f5f5f5;
+  padding: 20px;
+}
+
+.verify-email-card {
+  background: white;
+  border-radius: 8px;
+  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
+  width: 100%;
+  max-width: 500px;
+  padding: 40px;
+}
+
+.verify-email-header {
+  text-align: center;
+  margin-bottom: 32px;
+
+  .verify-email-icon {
+    font-size: 48px;
+    color: #1890ff;
+    display: block;
+    margin-bottom: 16px;
+  }
+
+  h2 {
+    font-size: 24px;
+    font-weight: 600;
+    color: #262626;
+    margin: 0;
+  }
+}
+
+.verify-email-content {
+  .info-text {
+    text-align: center;
+    margin-bottom: 24px;
+
+    p {
+      color: #666;
+      margin-bottom: 12px;
+      line-height: 1.5;
+    }
+
+    .email-display {
+      font-weight: 600;
+      color: #1890ff;
+      font-size: 16px;
+    }
+  }
+
+  .token-prompt {
+    .resend-section {
+      display: flex;
+      flex-direction: column;
+      gap: 16px;
+
+      .email-input {
+        max-width: 300px;
+        margin: 0 auto;
+      }
+
+      .resend-button {
+        max-width: 200px;
+        margin: 0 auto;
+      }
+    }
+  }
+}
+
+.verify-email-loading {
+  text-align: center;
+  padding: 40px 0;
+
+  nz-spin {
+    display: block;
+    margin-bottom: 16px;
+  }
+
+  p {
+    color: #666;
+    margin: 0;
+  }
+}
+
+.verify-email-error {
+  text-align: center;
+
+  .error-actions {
+    display: flex;
+    gap: 12px;
+    justify-content: center;
+    margin-top: 24px;
+  }
+}
+
+.verify-email-success {
+  text-align: center;
+}
+
+@media (max-width: 576px) {
+  .verify-email-card {
+    padding: 24px;
+  }
+
+  .verify-email-content .token-prompt .resend-section {
+    .email-input {
+      max-width: 100%;
+    }
+
+    .resend-button {
+      max-width: 100%;
+    }
+  }
+}
\ No newline at end of file
diff --git a/frontend/src/app/features/auth/verify-email/verify-email.component.ts b/frontend/src/app/features/auth/verify-email/verify-email.component.ts
new file mode 100644
index 0000000..736bda9
--- /dev/null
+++ b/frontend/src/app/features/auth/verify-email/verify-email.component.ts
@@ -0,0 +1,108 @@
+import { Component } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { FormsModule } from '@angular/forms';
+import { NzIconModule } from 'ng-zorro-antd/icon';
+import { NzSpinModule } from 'ng-zorro-antd/spin';
+import { NzButtonModule } from 'ng-zorro-antd/button';
+import { NzInputModule } from 'ng-zorro-antd/input';
+import { NzAlertModule } from 'ng-zorro-antd/alert';
+import { NzMessageService } from 'ng-zorro-antd/message';
+import { Router, RouterLink } from '@angular/router';
+import { AuthService } from '../../../core/services/auth.service';
+import { VerifyEmailResponse } from '../../../core/models/auth.model';
+
+@Component({
+  selector: 'app-verify-email',
+  standalone: true,
+  imports: [
+    CommonModule,
+    FormsModule,
+    NzIconModule,
+    NzSpinModule,
+    NzButtonModule,
+    NzInputModule,
+    NzAlertModule,
+    RouterLink
+  ],
+  templateUrl: './verify-email.component.html',
+  styleUrls: ['./verify-email.component.scss']
+})
+export class VerifyEmailComponent {
+  isLoading = false;
+  isSuccess = false;
+  isError = false;
+  errorMessage = '';
+  email = '';
+  token = '';
+
+  constructor(
+    private authService: AuthService,
+    private router: Router,
+    private message: NzMessageService
+  ) {
+    // Get token from URL
+    const urlParams = new URLSearchParams(window.location.search);
+    this.token = urlParams.get('token') || '';
+    this.email = urlParams.get('email') || '';
+  }
+
+  verifyEmail(): void {
+    if (!this.token) {
+      this.errorMessage = 'Verification token is required';
+      this.isError = true;
+      return;
+    }
+
+    this.isLoading = true;
+    this.isError = false;
+
+    this.authService.verifyEmail(this.token).subscribe({
+      next: (response: VerifyEmailResponse) => {
+        if (response.success) {
+          this.isSuccess = true;
+          this.email = response.email || this.email;
+          this.message.success('Email verified successfully!');
+
+          // Redirect to login after a delay
+          setTimeout(() => {
+            this.router.navigate(['/login']);
+          }, 3000);
+        } else {
+          this.isError = true;
+          this.errorMessage = response.errorMessage || 'Verification failed';
+          this.message.error(this.errorMessage);
+        }
+      },
+      error: (error) => {
+        this.isLoading = false;
+        this.isError = true;
+        this.errorMessage = error.error?.message || 'An error occurred during verification';
+        this.message.error(this.errorMessage);
+      },
+      complete: () => {
+        this.isLoading = false;
+      }
+    });
+  }
+
+  resendVerification(): void {
+    if (!this.email) {
+      this.message.warning('Email address is required');
+      return;
+    }
+
+    this.isLoading = true;
+    this.authService.resendVerification(this.email).subscribe({
+      next: () => {
+        this.message.success(`Verification email resent to ${this.email}`);
+      },
+      error: (error) => {
+        this.isLoading = false;
+        this.message.error(error.error?.message || 'Failed to resend verification email');
+      },
+      complete: () => {
+        this.isLoading = false;
+      }
+    });
+  }
+}
\ No newline at end of file
diff --git a/frontend/src/app/features/dashboard/dashboard.component.html b/frontend/src/app/features/dashboard/dashboard.component.html
new file mode 100644
index 0000000..ae90443
--- /dev/null
+++ b/frontend/src/app/features/dashboard/dashboard.component.html
@@ -0,0 +1,78 @@
+<div class="dashboard-container">
+  <div class="dashboard-header">
+    <h1>Dashboard</h1>
+    <button nz-button (click)="logout()" nzDanger>Logout</button>
+  </div>
+
+  @if (!isEmailVerified) {
+    <nz-alert
+      nzType="warning"
+      nzBanner
+      nzCloseable
+      nzMessage="Please verify your email address to access all features."
+      nzAction="<button nz-button nzSize='small' (click)='resendVerification()'>Resend Email</button>"
+    >
+    </nz-alert>
+  }
+
+  <div class="dashboard-content">
+    <nz-card>
+      <nz-card-meta
+        [nzAvatar]="user?.firstName?.[0] + (user?.lastName?.[0] || '') || 'U'"
+        [nzTitle]="'Welcome, ' + (user?.firstName + ' ' + user?.lastName || 'User')"
+        [nzDescription]="user?.email"
+      >
+        <div nz-card-meta-title>
+          <span class="user-email">{{ user?.email }}</span>
+          @if (!isEmailVerified) {
+            <nz-tag nzColor="warning">Unverified</nz-tag>
+          } @else {
+            <nz-tag nzColor="success">Verified</nz-tag>
+          }
+        </div>
+      </nz-card-meta>
+    </nz-card>
+
+    <div class="dashboard-grid">
+      <nz-card nzTitle="Quick Actions" [nzExtra]="['']">
+        <div class="quick-actions">
+          <button nz-button nzType="primary">
+            <i nz-icon nzType="plus"></i>
+            New Project
+          </button>
+          <button nz-button nzType="default">
+            <i nz-icon nzType="file"></i>
+            Documents
+          </button>
+          <button nz-button nzType="default">
+            <i nz-icon nzType="team"></i>
+            Team
+          </button>
+          <button nz-button nzType="default">
+            <i nz-icon nzType="setting"></i>
+            Settings
+          </button>
+        </div>
+      </nz-card>
+
+      <nz-card nzTitle="Recent Activity">
+        <p>No recent activity to display.</p>
+      </nz-card>
+
+      <nz-card nzTitle="System Status">
+        <div class="status-item">
+          <span class="status-label">Database:</span>
+          <span class="status-value status-connected">Connected</span>
+        </div>
+        <div class="status-item">
+          <span class="status-label">API:</span>
+          <span class="status-value status-connected">Online</span>
+        </div>
+        <div class="status-item">
+          <span class="status-label">Storage:</span>
+          <span class="status-value status-warning">75% Used</span>
+        </div>
+      </nz-card>
+    </div>
+  </div>
+</div>
\ No newline at end of file
diff --git a/frontend/src/app/features/dashboard/dashboard.component.scss b/frontend/src/app/features/dashboard/dashboard.component.scss
new file mode 100644
index 0000000..f779d94
--- /dev/null
+++ b/frontend/src/app/features/dashboard/dashboard.component.scss
@@ -0,0 +1,120 @@
+.dashboard-container {
+  min-height: 100vh;
+  background-color: #f5f7fa;
+  padding: 24px;
+
+  .dashboard-header {
+    display: flex;
+    justify-content: space-between;
+    align-items: center;
+    margin-bottom: 24px;
+
+    h1 {
+      font-size: 24px;
+      font-weight: 600;
+      color: #1a202c;
+      margin: 0;
+    }
+  }
+
+  .dashboard-content {
+    max-width: 1200px;
+    margin: 0 auto;
+
+    nz-card {
+      margin-bottom: 24px;
+
+      &:last-child {
+        margin-bottom: 0;
+      }
+    }
+
+    .dashboard-grid {
+      display: grid;
+      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
+      gap: 24px;
+      margin-top: 24px;
+    }
+  }
+}
+
+.quick-actions {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
+  gap: 16px;
+
+  button {
+    display: flex;
+    align-items: center;
+    justify-content: center;
+    gap: 8px;
+    height: 60px;
+    font-size: 14px;
+    font-weight: 500;
+  }
+}
+
+.status-item {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  padding: 8px 0;
+  border-bottom: 1px solid #f0f0f0;
+
+  &:last-child {
+    border-bottom: none;
+  }
+
+  .status-label {
+    font-weight: 500;
+    color: #666;
+  }
+
+  .status-value {
+    font-weight: 600;
+
+    &.status-connected {
+      color: #52c41a;
+    }
+
+    &.status-warning {
+      color: #faad14;
+    }
+
+    &.status-error {
+      color: #f5222d;
+    }
+  }
+}
+
+.user-email {
+  display: flex;
+  align-items: center;
+  gap: 8px;
+
+  .ant-tag {
+    font-size: 12px;
+    font-weight: 600;
+  }
+}
+
+// Responsive design
+@media (max-width: 768px) {
+  .dashboard-container {
+    padding: 16px;
+
+    .dashboard-header {
+      flex-direction: column;
+      gap: 16px;
+      align-items: flex-start;
+    }
+
+    .quick-actions {
+      grid-template-columns: 1fr;
+    }
+
+    .dashboard-grid {
+      grid-template-columns: 1fr;
+    }
+  }
+}
\ No newline at end of file
diff --git a/frontend/src/app/features/dashboard/dashboard.component.ts b/frontend/src/app/features/dashboard/dashboard.component.ts
new file mode 100644
index 0000000..c502a5d
--- /dev/null
+++ b/frontend/src/app/features/dashboard/dashboard.component.ts
@@ -0,0 +1,69 @@
+import { Component, OnInit } from '@angular/core';
+import { Router } from '@angular/router';
+import { CommonModule } from '@angular/common';
+import { NzMessageService } from 'ng-zorro-antd/message';
+import { NzCardModule } from 'ng-zorro-antd/card';
+import { NzButtonModule } from 'ng-zorro-antd/button';
+import { NzIconModule } from 'ng-zorro-antd/icon';
+import { NzAlertModule } from 'ng-zorro-antd/alert';
+import { AuthService } from '../../../core/services/auth.service';
+
+@Component({
+  selector: 'app-dashboard',
+  standalone: true,
+  imports: [
+    CommonModule,
+    NzCardModule,
+    NzButtonModule,
+    NzIconModule,
+    NzAlertModule
+  ],
+  templateUrl: './dashboard.component.html',
+  styleUrls: ['./dashboard.component.scss']
+})
+export class DashboardComponent implements OnInit {
+  user: any = null;
+  isEmailVerified = false;
+
+  constructor(
+    private router: Router,
+    private message: NzMessageService,
+    private authService: AuthService
+  ) {}
+
+  ngOnInit(): void {
+    // Check if user is logged in
+    if (!localStorage.getItem('execora_access_token')) {
+      this.message.warning('Please login to access the dashboard');
+      this.router.navigate(['/login']);
+      return;
+    }
+
+    // Get user data
+    this.user = this.authService.currentUser;
+    if (this.user) {
+      this.isEmailVerified = this.user.emailVerified;
+    }
+  }
+
+  logout(): void {
+    localStorage.removeItem('execora_access_token');
+    localStorage.removeItem('execora_refresh_token');
+    localStorage.removeItem('execora_user');
+    this.message.success('You have been logged out');
+    this.router.navigate(['/login']);
+  }
+
+  resendVerification(): void {
+    if (this.user?.email) {
+      this.authService.resendVerification(this.user.email).subscribe({
+        next: () => {
+          this.message.success(`Verification email resent to ${this.user.email}`);
+        },
+        error: (error: any) => {
+          this.message.error(error?.error?.message || 'Failed to resend verification email');
+        }
+      });
+    }
+  }
+}
\ No newline at end of file
